module Utils

using LibGit2: GitRepo
using TOML
using TOML: parsefile, print as toml_print

export manifest_plugins_toml, project_plugins_toml, read_toml_if_exists,
	read_toml_required, with_repo, write_toml, is_hex_object_id, plugins_dir,
	plugin_store_dir, Workspace, workspace, find_workspace_root, PluginDefinition,
	parse_plugin_definition, collect_plugin_definitions, plugin_metadata_entry

# Path to the project-level plugin declaration file.
project_plugins_toml(base_dir::String = pwd()) = joinpath(base_dir, "Plugins.toml")

# Path to the local installation manifest generated by this package.
manifest_plugins_toml(base_dir::String = pwd()) = joinpath(base_dir, ".julia_plugins", "Plugins.toml")
plugins_dir(base_dir::String = pwd()) = joinpath(base_dir, "plugins")
plugin_store_dir(base_dir::String = pwd()) = joinpath(base_dir, ".julia_plugins")

struct Workspace
	root::String
end

function _workspace_markers(dir::String)
	(
		isfile(project_plugins_toml(dir)) ||
		isfile(manifest_plugins_toml(dir)) ||
		isdir(plugins_dir(dir))
	)
end

function find_workspace_root(start::String = pwd())
	start_dir = abspath(isfile(start) ? dirname(start) : start)
	current = start_dir
	while true
		_workspace_markers(current) && return current
		parent = dirname(current)
		parent == current && return start_dir
		current = parent
	end
end

function workspace(root::String = pwd(); discover::Bool = true)
	abs_root = normpath(abspath(root))
	Workspace(discover ? find_workspace_root(abs_root) : abs_root)
end

project_plugins_toml(workspace::Workspace) = project_plugins_toml(workspace.root)
manifest_plugins_toml(workspace::Workspace) = manifest_plugins_toml(workspace.root)
plugins_dir(workspace::Workspace) = plugins_dir(workspace.root)
plugin_store_dir(workspace::Workspace) = plugin_store_dir(workspace.root)

struct PluginDefinition
	name::String
	module_name::String
	version::VersionNumber
	deps::Vector{String}
	path::String
	entry_file::String
	is_dir::Bool
end

function read_toml_if_exists(path::String; default::Dict{String, Any} = Dict{String, Any}())
	isfile(path) ? parsefile(path) : deepcopy(default)
end

function read_toml_required(path::String; error_msg::Union{Nothing, String} = nothing)
	isfile(path) && return parsefile(path)
	msg = error_msg === nothing ? "File not found: $path" : error_msg
	error(msg)
end

function write_toml(path::String, data::Dict{String, Any})
	open(path, "w") do io
		toml_print(io, data)
	end
end

function is_hex_object_id(s::String; length_required::Int = 40)
	length(s) == length_required || return false
	all(c -> isdigit(c) || ('a' <= c <= 'f') || ('A' <= c <= 'F'), s)
end

# Open a Git repository, execute `f`, and always close the handle.
function with_repo(f::Function, path::String)
	repo = GitRepo(path)
	try
		return f(repo)
	finally
		close(repo)
	end
end

function _parse_module_name(content::String)
	m = match(r"(?m)^\s*module\s+([A-Za-z_][A-Za-z0-9_]*)", content)
	m === nothing && error("Plugin source must define a `module`.")
	String(m.captures[1])
end

function _parse_module_docstring(content::String, module_name::String)
	pat = Regex("(?s)\\\"\\\"\\\"(.*?)\\\"\\\"\\\"\\s*module\\s+$(module_name)\\b")
	m = match(pat, content)
	m === nothing && error("Plugin module `$module_name` must have a module docstring with metadata.")
	String(strip(m.captures[1]))
end

function _metadata_from_docstring(doc::String, plugin_name::String)
	meta = TOML.parse(doc)
	version_str = get(meta, "version", nothing)
	version_str isa String || error("Plugin `$plugin_name` docstring metadata must include `version = \"x.y.z\"`.")
	version = VersionNumber(version_str)

	deps_raw = get(meta, "deps", String[])
	deps = String[]
	for dep in deps_raw
		dep isa String || error("Plugin `$plugin_name` metadata `deps` must be a string list.")
		push!(deps, dep)
	end
	(version = version, deps = unique(deps))
end

function parse_plugin_definition(path::String)
	abs_path = abspath(path)
	ispath(abs_path) || error("Plugin path not found: $path")

	is_dir = isdir(abs_path)
	name = is_dir ? basename(abs_path) : basename(abs_path)
	if is_dir
		entry_file = joinpath(abs_path, "$name.jl")
		isfile(entry_file) || error("Plugin directory `$abs_path` must contain `$name.jl`.")
	else
		endswith(name, ".jl") || error("Plugin file must end with `.jl`: $abs_path")
		name = name[1:(end - 3)]
		entry_file = abs_path
	end

	content = read(entry_file, String)
	module_name = _parse_module_name(content)
	module_name == name || error("Plugin name `$name` must match module name `$module_name`.")
	doc = _parse_module_docstring(content, module_name)
	meta = _metadata_from_docstring(doc, name)

	PluginDefinition(name, module_name, meta.version, meta.deps, abs_path, entry_file, is_dir)
end

function collect_plugin_definitions(dir::String)
	isdir(dir) || return Dict{String, PluginDefinition}()
	defs = Dict{String, PluginDefinition}()
	for entry in sort(readdir(dir; join = true))
		b = basename(entry)
		startswith(b, ".") && continue
		if isdir(entry) || endswith(b, ".jl")
			def = parse_plugin_definition(entry)
			haskey(defs, def.name) && error("Duplicate plugin name `$((def.name))` in `$dir`.")
			defs[def.name] = def
		end
	end
	defs
end

function plugin_metadata_entry(def::PluginDefinition; namespace::String)
	ver_key = string(def.version)
	compat = isempty(def.deps) ? Dict{String, Any}() :
				Dict(ver_key => Dict(dep => "*" for dep in def.deps))
	dep_map = isempty(def.deps) ? Dict{String, Any}() : Dict(ver_key => def.deps)
	Dict{String, Any}(
		"name" => def.name,
		"module_name" => def.module_name,
		"namespace" => namespace,
		"versions" => Dict(ver_key => Dict("path" => def.path)),
		"deps" => dep_map,
		"compat" => compat,
	)
end

end#= module Utils =#
